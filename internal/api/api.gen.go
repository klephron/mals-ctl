// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

// CodeLensOptions defines model for CodeLensOptions.
type CodeLensOptions struct {
	ResolveProvider  *bool `json:"resolveProvider,omitempty"`
	WorkDoneProgress *bool `json:"workDoneProgress,omitempty"`
}

// CompletionOptions defines model for CompletionOptions.
type CompletionOptions struct {
	AllCommitCharacters *[]string                    `json:"allCommitCharacters"`
	CompletionItem      *ServerCompletionItemOptions `json:"completionItem,omitempty"`
	ResolveProvider     *bool                        `json:"resolveProvider,omitempty"`
	TriggerCharacters   *[]string                    `json:"triggerCharacters"`
	WorkDoneProgress    *bool                        `json:"workDoneProgress,omitempty"`
}

// Condition defines model for Condition.
type Condition struct {
	Filetypes *[]string `json:"Filetypes"`
	Paths     *[]string `json:"Paths"`
}

// DocumentLinkOptions defines model for DocumentLinkOptions.
type DocumentLinkOptions struct {
	ResolveProvider  *bool `json:"resolveProvider,omitempty"`
	WorkDoneProgress *bool `json:"workDoneProgress,omitempty"`
}

// DocumentOnTypeFormattingOptions defines model for DocumentOnTypeFormattingOptions.
type DocumentOnTypeFormattingOptions struct {
	FirstTriggerCharacter string    `json:"firstTriggerCharacter"`
	MoreTriggerCharacter  *[]string `json:"moreTriggerCharacter"`
}

// ErrorDetail defines model for ErrorDetail.
type ErrorDetail struct {
	// Location Where the error occurred, e.g. 'body.items[3].tags' or 'path.thing-id'
	Location *string `json:"location,omitempty"`

	// Message Error message text
	Message *string `json:"message,omitempty"`

	// Value The value at the given location
	Value interface{} `json:"value,omitempty"`
}

// ErrorModel defines model for ErrorModel.
type ErrorModel struct {
	// Schema A URL to the JSON Schema for this object.
	Schema *string `json:"$schema,omitempty"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Errors Optional list of individual error details
	Errors *[]ErrorDetail `json:"errors"`

	// Instance A URI reference that identifies the specific occurrence of the problem.
	Instance *string `json:"instance,omitempty"`

	// Status HTTP status code
	Status *int64 `json:"status,omitempty"`

	// Title A short, human-readable summary of the problem type. This value should not change between occurrences of the error.
	Title *string `json:"title,omitempty"`

	// Type A URI reference to human-readable documentation for the error.
	Type *string `json:"type,omitempty"`
}

// ExecuteCommandOptions defines model for ExecuteCommandOptions.
type ExecuteCommandOptions struct {
	Commands         *[]string `json:"commands"`
	WorkDoneProgress *bool     `json:"workDoneProgress,omitempty"`
}

// FileOperationFilter defines model for FileOperationFilter.
type FileOperationFilter struct {
	Pattern FileOperationPattern `json:"pattern"`
	Scheme  *string              `json:"scheme,omitempty"`
}

// FileOperationOptions defines model for FileOperationOptions.
type FileOperationOptions struct {
	DidCreate  *FileOperationRegistrationOptions `json:"didCreate,omitempty"`
	DidDelete  *FileOperationRegistrationOptions `json:"didDelete,omitempty"`
	DidRename  *FileOperationRegistrationOptions `json:"didRename,omitempty"`
	WillCreate *FileOperationRegistrationOptions `json:"willCreate,omitempty"`
	WillDelete *FileOperationRegistrationOptions `json:"willDelete,omitempty"`
	WillRename *FileOperationRegistrationOptions `json:"willRename,omitempty"`
}

// FileOperationPattern defines model for FileOperationPattern.
type FileOperationPattern struct {
	Glob    string                       `json:"glob"`
	Matches *string                      `json:"matches,omitempty"`
	Options *FileOperationPatternOptions `json:"options,omitempty"`
}

// FileOperationPatternOptions defines model for FileOperationPatternOptions.
type FileOperationPatternOptions struct {
	IgnoreCase *bool `json:"ignoreCase,omitempty"`
}

// FileOperationRegistrationOptions defines model for FileOperationRegistrationOptions.
type FileOperationRegistrationOptions struct {
	Filters *[]FileOperationFilter `json:"filters"`
}

// ListenerDto defines model for ListenerDto.
type ListenerDto struct {
	// Schema A URL to the JSON Schema for this object.
	Schema      *string      `json:"$schema,omitempty"`
	Config      WireListener `json:"config"`
	Name        string       `json:"name"`
	Status      int32        `json:"status"`
	StatusFlags *[]string    `json:"status_flags"`
}

// LogDto defines model for LogDto.
type LogDto struct {
	// Schema A URL to the JSON Schema for this object.
	Schema      *string   `json:"$schema,omitempty"`
	Config      WireLog   `json:"config"`
	Name        string    `json:"name"`
	Status      int32     `json:"status"`
	StatusFlags *[]string `json:"status_flags"`
}

// LspDto defines model for LspDto.
type LspDto struct {
	// Schema A URL to the JSON Schema for this object.
	Schema       *string            `json:"$schema,omitempty"`
	Capabilities ServerCapabilities `json:"capabilities"`
	Config       WireLsp            `json:"config"`
	Info         ServerInfo         `json:"info"`
	Name         string             `json:"name"`
	Status       int32              `json:"status"`
	StatusFlags  *[]string          `json:"status_flags"`
}

// ModelDto defines model for ModelDto.
type ModelDto struct {
	// Schema A URL to the JSON Schema for this object.
	Schema      *string   `json:"$schema,omitempty"`
	Config      WireModel `json:"config"`
	Name        string    `json:"name"`
	Status      int32     `json:"status"`
	StatusFlags *[]string `json:"status_flags"`
	Tasks       *[]Task   `json:"tasks"`
}

// OrServerCapabilitiesCallHierarchyProvider defines model for Or_ServerCapabilities_callHierarchyProvider.
type OrServerCapabilitiesCallHierarchyProvider struct {
	Value interface{} `json:"value"`
}

// OrServerCapabilitiesColorProvider defines model for Or_ServerCapabilities_colorProvider.
type OrServerCapabilitiesColorProvider struct {
	Value interface{} `json:"value"`
}

// OrServerCapabilitiesDeclarationProvider defines model for Or_ServerCapabilities_declarationProvider.
type OrServerCapabilitiesDeclarationProvider struct {
	Value interface{} `json:"value"`
}

// OrServerCapabilitiesDefinitionProvider defines model for Or_ServerCapabilities_definitionProvider.
type OrServerCapabilitiesDefinitionProvider struct {
	Value interface{} `json:"value"`
}

// OrServerCapabilitiesDiagnosticProvider defines model for Or_ServerCapabilities_diagnosticProvider.
type OrServerCapabilitiesDiagnosticProvider struct {
	Value interface{} `json:"value"`
}

// OrServerCapabilitiesDocumentFormattingProvider defines model for Or_ServerCapabilities_documentFormattingProvider.
type OrServerCapabilitiesDocumentFormattingProvider struct {
	Value interface{} `json:"value"`
}

// OrServerCapabilitiesDocumentHighlightProvider defines model for Or_ServerCapabilities_documentHighlightProvider.
type OrServerCapabilitiesDocumentHighlightProvider struct {
	Value interface{} `json:"value"`
}

// OrServerCapabilitiesDocumentRangeFormattingProvider defines model for Or_ServerCapabilities_documentRangeFormattingProvider.
type OrServerCapabilitiesDocumentRangeFormattingProvider struct {
	Value interface{} `json:"value"`
}

// OrServerCapabilitiesDocumentSymbolProvider defines model for Or_ServerCapabilities_documentSymbolProvider.
type OrServerCapabilitiesDocumentSymbolProvider struct {
	Value interface{} `json:"value"`
}

// OrServerCapabilitiesFoldingRangeProvider defines model for Or_ServerCapabilities_foldingRangeProvider.
type OrServerCapabilitiesFoldingRangeProvider struct {
	Value interface{} `json:"value"`
}

// OrServerCapabilitiesHoverProvider defines model for Or_ServerCapabilities_hoverProvider.
type OrServerCapabilitiesHoverProvider struct {
	Value interface{} `json:"value"`
}

// OrServerCapabilitiesImplementationProvider defines model for Or_ServerCapabilities_implementationProvider.
type OrServerCapabilitiesImplementationProvider struct {
	Value interface{} `json:"value"`
}

// OrServerCapabilitiesInlineCompletionProvider defines model for Or_ServerCapabilities_inlineCompletionProvider.
type OrServerCapabilitiesInlineCompletionProvider struct {
	Value interface{} `json:"value"`
}

// OrServerCapabilitiesInlineValueProvider defines model for Or_ServerCapabilities_inlineValueProvider.
type OrServerCapabilitiesInlineValueProvider struct {
	Value interface{} `json:"value"`
}

// OrServerCapabilitiesLinkedEditingRangeProvider defines model for Or_ServerCapabilities_linkedEditingRangeProvider.
type OrServerCapabilitiesLinkedEditingRangeProvider struct {
	Value interface{} `json:"value"`
}

// OrServerCapabilitiesMonikerProvider defines model for Or_ServerCapabilities_monikerProvider.
type OrServerCapabilitiesMonikerProvider struct {
	Value interface{} `json:"value"`
}

// OrServerCapabilitiesNotebookDocumentSync defines model for Or_ServerCapabilities_notebookDocumentSync.
type OrServerCapabilitiesNotebookDocumentSync struct {
	Value interface{} `json:"value"`
}

// OrServerCapabilitiesReferencesProvider defines model for Or_ServerCapabilities_referencesProvider.
type OrServerCapabilitiesReferencesProvider struct {
	Value interface{} `json:"value"`
}

// OrServerCapabilitiesSelectionRangeProvider defines model for Or_ServerCapabilities_selectionRangeProvider.
type OrServerCapabilitiesSelectionRangeProvider struct {
	Value interface{} `json:"value"`
}

// OrServerCapabilitiesTypeDefinitionProvider defines model for Or_ServerCapabilities_typeDefinitionProvider.
type OrServerCapabilitiesTypeDefinitionProvider struct {
	Value interface{} `json:"value"`
}

// OrServerCapabilitiesTypeHierarchyProvider defines model for Or_ServerCapabilities_typeHierarchyProvider.
type OrServerCapabilitiesTypeHierarchyProvider struct {
	Value interface{} `json:"value"`
}

// OrServerCapabilitiesWorkspaceSymbolProvider defines model for Or_ServerCapabilities_workspaceSymbolProvider.
type OrServerCapabilitiesWorkspaceSymbolProvider struct {
	Value interface{} `json:"value"`
}

// OrWorkspaceOptionsTextDocumentContent defines model for Or_WorkspaceOptions_textDocumentContent.
type OrWorkspaceOptionsTextDocumentContent struct {
	Value interface{} `json:"value"`
}

// ResourceLspDto defines model for ResourceLspDto.
type ResourceLspDto struct {
	Dependencies map[string]ScopeTokenDto `json:"dependencies"`
	Fullname     string                   `json:"fullname"`
}

// ResourceModelDto defines model for ResourceModelDto.
type ResourceModelDto struct {
	Dependencies map[string]ScopeTokenDto `json:"dependencies"`
	Fullname     string                   `json:"fullname"`
}

// ScopeTokenDto defines model for ScopeTokenDto.
type ScopeTokenDto struct {
	From string `json:"from"`
}

// ServerCapabilities defines model for ServerCapabilities.
type ServerCapabilities struct {
	CallHierarchyProvider            *OrServerCapabilitiesCallHierarchyProvider           `json:"callHierarchyProvider,omitempty"`
	CodeActionProvider               interface{}                                          `json:"codeActionProvider,omitempty"`
	CodeLensProvider                 *CodeLensOptions                                     `json:"codeLensProvider,omitempty"`
	ColorProvider                    *OrServerCapabilitiesColorProvider                   `json:"colorProvider,omitempty"`
	CompletionProvider               *CompletionOptions                                   `json:"completionProvider,omitempty"`
	DeclarationProvider              *OrServerCapabilitiesDeclarationProvider             `json:"declarationProvider,omitempty"`
	DefinitionProvider               *OrServerCapabilitiesDefinitionProvider              `json:"definitionProvider,omitempty"`
	DiagnosticProvider               *OrServerCapabilitiesDiagnosticProvider              `json:"diagnosticProvider,omitempty"`
	DocumentFormattingProvider       *OrServerCapabilitiesDocumentFormattingProvider      `json:"documentFormattingProvider,omitempty"`
	DocumentHighlightProvider        *OrServerCapabilitiesDocumentHighlightProvider       `json:"documentHighlightProvider,omitempty"`
	DocumentLinkProvider             *DocumentLinkOptions                                 `json:"documentLinkProvider,omitempty"`
	DocumentOnTypeFormattingProvider *DocumentOnTypeFormattingOptions                     `json:"documentOnTypeFormattingProvider,omitempty"`
	DocumentRangeFormattingProvider  *OrServerCapabilitiesDocumentRangeFormattingProvider `json:"documentRangeFormattingProvider,omitempty"`
	DocumentSymbolProvider           *OrServerCapabilitiesDocumentSymbolProvider          `json:"documentSymbolProvider,omitempty"`
	ExecuteCommandProvider           *ExecuteCommandOptions                               `json:"executeCommandProvider,omitempty"`
	Experimental                     interface{}                                          `json:"experimental,omitempty"`
	FoldingRangeProvider             *OrServerCapabilitiesFoldingRangeProvider            `json:"foldingRangeProvider,omitempty"`
	HoverProvider                    *OrServerCapabilitiesHoverProvider                   `json:"hoverProvider,omitempty"`
	ImplementationProvider           *OrServerCapabilitiesImplementationProvider          `json:"implementationProvider,omitempty"`
	InlayHintProvider                interface{}                                          `json:"inlayHintProvider,omitempty"`
	InlineCompletionProvider         *OrServerCapabilitiesInlineCompletionProvider        `json:"inlineCompletionProvider,omitempty"`
	InlineValueProvider              *OrServerCapabilitiesInlineValueProvider             `json:"inlineValueProvider,omitempty"`
	LinkedEditingRangeProvider       *OrServerCapabilitiesLinkedEditingRangeProvider      `json:"linkedEditingRangeProvider,omitempty"`
	MonikerProvider                  *OrServerCapabilitiesMonikerProvider                 `json:"monikerProvider,omitempty"`
	NotebookDocumentSync             *OrServerCapabilitiesNotebookDocumentSync            `json:"notebookDocumentSync,omitempty"`
	PositionEncoding                 *string                                              `json:"positionEncoding,omitempty"`
	ReferencesProvider               *OrServerCapabilitiesReferencesProvider              `json:"referencesProvider,omitempty"`
	RenameProvider                   interface{}                                          `json:"renameProvider,omitempty"`
	SelectionRangeProvider           *OrServerCapabilitiesSelectionRangeProvider          `json:"selectionRangeProvider,omitempty"`
	SemanticTokensProvider           interface{}                                          `json:"semanticTokensProvider,omitempty"`
	SignatureHelpProvider            *SignatureHelpOptions                                `json:"signatureHelpProvider,omitempty"`
	TextDocumentSync                 interface{}                                          `json:"textDocumentSync,omitempty"`
	TypeDefinitionProvider           *OrServerCapabilitiesTypeDefinitionProvider          `json:"typeDefinitionProvider,omitempty"`
	TypeHierarchyProvider            *OrServerCapabilitiesTypeHierarchyProvider           `json:"typeHierarchyProvider,omitempty"`
	Workspace                        *WorkspaceOptions                                    `json:"workspace,omitempty"`
	WorkspaceSymbolProvider          *OrServerCapabilitiesWorkspaceSymbolProvider         `json:"workspaceSymbolProvider,omitempty"`
}

// ServerCompletionItemOptions defines model for ServerCompletionItemOptions.
type ServerCompletionItemOptions struct {
	LabelDetailsSupport *bool `json:"labelDetailsSupport,omitempty"`
}

// ServerInfo defines model for ServerInfo.
type ServerInfo struct {
	Name    string  `json:"name"`
	Version *string `json:"version,omitempty"`
}

// SignatureHelpOptions defines model for SignatureHelpOptions.
type SignatureHelpOptions struct {
	RetriggerCharacters *[]string `json:"retriggerCharacters"`
	TriggerCharacters   *[]string `json:"triggerCharacters"`
	WorkDoneProgress    *bool     `json:"workDoneProgress,omitempty"`
}

// SpaceDto defines model for SpaceDto.
type SpaceDto struct {
	// Schema A URL to the JSON Schema for this object.
	Schema   *string                     `json:"$schema,omitempty"`
	Children map[string]SpaceDto         `json:"children"`
	Lsps     map[string]ResourceLspDto   `json:"lsps"`
	Models   map[string]ResourceModelDto `json:"models"`
	Name     string                      `json:"name"`
}

// Step defines model for Step.
type Step struct {
	Conditions *[]Condition `json:"Conditions"`
	Kind       interface{}  `json:"Kind"`
	Name       string       `json:"Name"`
	Scope      string       `json:"Scope"`
}

// Task defines model for Task.
type Task struct {
	Id                string      `json:"id"`
	Schema            interface{} `json:"schema"`
	SchemaDescription string      `json:"schema_description"`
	SchemaName        string      `json:"schema_name"`
	SchemaStrict      bool        `json:"schema_strict"`
	Text              string      `json:"text"`
}

// UsageDto defines model for UsageDto.
type UsageDto struct {
	// Schema A URL to the JSON Schema for this object.
	Schema     *string      `json:"$schema,omitempty"`
	Conditions *[]Condition `json:"conditions"`
	Events     *[]string    `json:"events"`
	Name       string       `json:"name"`
	Workflow   Workflow     `json:"workflow"`
}

// WireListener defines model for WireListener.
type WireListener struct {
	Ipc    string    `json:"ipc"`
	Kind   string    `json:"kind"`
	Name   string    `json:"name"`
	Port   *int64    `json:"port"`
	Usages *[]string `json:"usages"`
}

// WireLog defines model for WireLog.
type WireLog struct {
	File  *string `json:"file"`
	Kind  string  `json:"kind"`
	Level string  `json:"level"`
	Name  string  `json:"name"`
}

// WireLsp defines model for WireLsp.
type WireLsp struct {
	Kind     string          `json:"kind"`
	Name     string          `json:"name"`
	Settings WireLspSettings `json:"settings"`
}

// WireLspSettings defines model for WireLspSettings.
type WireLspSettings struct {
	Cmd *[]string `json:"cmd"`
}

// WireModel defines model for WireModel.
type WireModel struct {
	Kind     string            `json:"kind"`
	Name     string            `json:"name"`
	Settings WireModelSettings `json:"settings"`
}

// WireModelSettings defines model for WireModelSettings.
type WireModelSettings struct {
	MaxTokens   int64   `json:"max_tokens"`
	Temperature float32 `json:"temperature"`
	Url         string  `json:"url"`
}

// Workflow defines model for Workflow.
type Workflow struct {
	Steps *[]Step `json:"Steps"`
}

// WorkspaceFolders5Gn defines model for WorkspaceFolders5Gn.
type WorkspaceFolders5Gn struct {
	ChangeNotifications *string `json:"changeNotifications,omitempty"`
	Supported           *bool   `json:"supported,omitempty"`
}

// WorkspaceOptions defines model for WorkspaceOptions.
type WorkspaceOptions struct {
	FileOperations      *FileOperationOptions                  `json:"fileOperations,omitempty"`
	TextDocumentContent *OrWorkspaceOptionsTextDocumentContent `json:"textDocumentContent,omitempty"`
	WorkspaceFolders    *WorkspaceFolders5Gn                   `json:"workspaceFolders,omitempty"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListenerGetAll request
	ListenerGetAll(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListenerGet request
	ListenerGet(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogGetAll request
	LogGetAll(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogGet request
	LogGet(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LspGetAll request
	LspGetAll(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LspGet request
	LspGet(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelGetAll request
	ModelGetAll(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModelGet request
	ModelGet(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScopeTreeRoot request
	ScopeTreeRoot(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsageGetAll request
	UsageGetAll(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsageGet request
	UsageGet(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListenerGetAll(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListenerGetAllRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListenerGet(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListenerGetRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogGetAll(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogGetAllRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogGet(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogGetRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LspGetAll(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLspGetAllRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LspGet(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLspGetRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelGetAll(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelGetAllRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModelGet(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModelGetRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScopeTreeRoot(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScopeTreeRootRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsageGetAll(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsageGetAllRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsageGet(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsageGetRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListenerGetAllRequest generates requests for ListenerGetAll
func NewListenerGetAllRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listeners")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListenerGetRequest generates requests for ListenerGet
func NewListenerGetRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listeners/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogGetAllRequest generates requests for LogGetAll
func NewLogGetAllRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogGetRequest generates requests for LogGet
func NewLogGetRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLspGetAllRequest generates requests for LspGetAll
func NewLspGetAllRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lsps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLspGetRequest generates requests for LspGet
func NewLspGetRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/lsps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModelGetAllRequest generates requests for ModelGetAll
func NewModelGetAllRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModelGetRequest generates requests for ModelGet
func NewModelGetRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScopeTreeRootRequest generates requests for ScopeTreeRoot
func NewScopeTreeRootRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scopes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsageGetAllRequest generates requests for UsageGetAll
func NewUsageGetAllRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/usages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsageGetRequest generates requests for UsageGet
func NewUsageGetRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/usages/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListenerGetAllWithResponse request
	ListenerGetAllWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListenerGetAllResponse, error)

	// ListenerGetWithResponse request
	ListenerGetWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*ListenerGetResponse, error)

	// LogGetAllWithResponse request
	LogGetAllWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogGetAllResponse, error)

	// LogGetWithResponse request
	LogGetWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*LogGetResponse, error)

	// LspGetAllWithResponse request
	LspGetAllWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LspGetAllResponse, error)

	// LspGetWithResponse request
	LspGetWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*LspGetResponse, error)

	// ModelGetAllWithResponse request
	ModelGetAllWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ModelGetAllResponse, error)

	// ModelGetWithResponse request
	ModelGetWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*ModelGetResponse, error)

	// ScopeTreeRootWithResponse request
	ScopeTreeRootWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ScopeTreeRootResponse, error)

	// UsageGetAllWithResponse request
	UsageGetAllWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UsageGetAllResponse, error)

	// UsageGetWithResponse request
	UsageGetWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*UsageGetResponse, error)
}

type ListenerGetAllResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]ListenerDto
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r ListenerGetAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListenerGetAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListenerGetResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *ListenerDto
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r ListenerGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListenerGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogGetAllResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]LogDto
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r LogGetAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogGetAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogGetResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *LogDto
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r LogGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LspGetAllResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]LspDto
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r LspGetAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LspGetAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LspGetResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *LspDto
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r LspGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LspGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelGetAllResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]ModelDto
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r ModelGetAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelGetAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModelGetResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *ModelDto
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r ModelGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModelGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScopeTreeRootResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *SpaceDto
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r ScopeTreeRootResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScopeTreeRootResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsageGetAllResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *[]UsageDto
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r UsageGetAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsageGetAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsageGetResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *UsageDto
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r UsageGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsageGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListenerGetAllWithResponse request returning *ListenerGetAllResponse
func (c *ClientWithResponses) ListenerGetAllWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListenerGetAllResponse, error) {
	rsp, err := c.ListenerGetAll(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListenerGetAllResponse(rsp)
}

// ListenerGetWithResponse request returning *ListenerGetResponse
func (c *ClientWithResponses) ListenerGetWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*ListenerGetResponse, error) {
	rsp, err := c.ListenerGet(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListenerGetResponse(rsp)
}

// LogGetAllWithResponse request returning *LogGetAllResponse
func (c *ClientWithResponses) LogGetAllWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogGetAllResponse, error) {
	rsp, err := c.LogGetAll(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogGetAllResponse(rsp)
}

// LogGetWithResponse request returning *LogGetResponse
func (c *ClientWithResponses) LogGetWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*LogGetResponse, error) {
	rsp, err := c.LogGet(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogGetResponse(rsp)
}

// LspGetAllWithResponse request returning *LspGetAllResponse
func (c *ClientWithResponses) LspGetAllWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LspGetAllResponse, error) {
	rsp, err := c.LspGetAll(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLspGetAllResponse(rsp)
}

// LspGetWithResponse request returning *LspGetResponse
func (c *ClientWithResponses) LspGetWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*LspGetResponse, error) {
	rsp, err := c.LspGet(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLspGetResponse(rsp)
}

// ModelGetAllWithResponse request returning *ModelGetAllResponse
func (c *ClientWithResponses) ModelGetAllWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ModelGetAllResponse, error) {
	rsp, err := c.ModelGetAll(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelGetAllResponse(rsp)
}

// ModelGetWithResponse request returning *ModelGetResponse
func (c *ClientWithResponses) ModelGetWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*ModelGetResponse, error) {
	rsp, err := c.ModelGet(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModelGetResponse(rsp)
}

// ScopeTreeRootWithResponse request returning *ScopeTreeRootResponse
func (c *ClientWithResponses) ScopeTreeRootWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ScopeTreeRootResponse, error) {
	rsp, err := c.ScopeTreeRoot(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScopeTreeRootResponse(rsp)
}

// UsageGetAllWithResponse request returning *UsageGetAllResponse
func (c *ClientWithResponses) UsageGetAllWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UsageGetAllResponse, error) {
	rsp, err := c.UsageGetAll(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsageGetAllResponse(rsp)
}

// UsageGetWithResponse request returning *UsageGetResponse
func (c *ClientWithResponses) UsageGetWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*UsageGetResponse, error) {
	rsp, err := c.UsageGet(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsageGetResponse(rsp)
}

// ParseListenerGetAllResponse parses an HTTP response from a ListenerGetAllWithResponse call
func ParseListenerGetAllResponse(rsp *http.Response) (*ListenerGetAllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListenerGetAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ListenerDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseListenerGetResponse parses an HTTP response from a ListenerGetWithResponse call
func ParseListenerGetResponse(rsp *http.Response) (*ListenerGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListenerGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListenerDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseLogGetAllResponse parses an HTTP response from a LogGetAllWithResponse call
func ParseLogGetAllResponse(rsp *http.Response) (*LogGetAllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogGetAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LogDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseLogGetResponse parses an HTTP response from a LogGetWithResponse call
func ParseLogGetResponse(rsp *http.Response) (*LogGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseLspGetAllResponse parses an HTTP response from a LspGetAllWithResponse call
func ParseLspGetAllResponse(rsp *http.Response) (*LspGetAllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LspGetAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LspDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseLspGetResponse parses an HTTP response from a LspGetWithResponse call
func ParseLspGetResponse(rsp *http.Response) (*LspGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LspGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LspDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseModelGetAllResponse parses an HTTP response from a ModelGetAllWithResponse call
func ParseModelGetAllResponse(rsp *http.Response) (*ModelGetAllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelGetAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ModelDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseModelGetResponse parses an HTTP response from a ModelGetWithResponse call
func ParseModelGetResponse(rsp *http.Response) (*ModelGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModelGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModelDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseScopeTreeRootResponse parses an HTTP response from a ScopeTreeRootWithResponse call
func ParseScopeTreeRootResponse(rsp *http.Response) (*ScopeTreeRootResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScopeTreeRootResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpaceDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUsageGetAllResponse parses an HTTP response from a UsageGetAllWithResponse call
func ParseUsageGetAllResponse(rsp *http.Response) (*UsageGetAllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsageGetAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UsageDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUsageGetResponse parses an HTTP response from a UsageGetWithResponse call
func ParseUsageGetResponse(rsp *http.Response) (*UsageGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsageGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsageDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}
